/**
 * Homelab 3 basic functions
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include "htp.h"
// #include "fs.h"
// #include "basic.h"
// #include "params.h"
// #include "labels.h"
#include <ctype.h>

#define BASIC_START 0x40A0
#define MAX_LINE_LENGTH 1000

/**
 * A tokentábla eleje az 1C3C címen van, de az első hasznos adat az 1C3D címen
 * A tokenek a 0x1C3D - 0x1D3D címen kezdődnek, de csak a C8 tokenig. Aztán 0x265F címtől (Key) E4-ig
 * A token utolsó karakterének a 7. bitje 1-es, a többi karakternél ez a bit 0.
 * A token kódja az ebben a táblázabna elfoglalt indexe 0-ától számozva + 128.
 * Például a ^ token kódja : 0x80. Ez az első token a listában, tehát az indexe 0. Ehhez jön még a +128.
 *         a + token kódja : 43 0x81. Ez a második token a listában, tehát az indexe 1. Ehhez jön még a +128.
 */
const unsigned char tokens[] = { 0xde, 0xab, 0xad,
0xaa, 0xaf, 0xbe, 0xbc, 0xbd, 0x50, 0xe9, 0x52, 0x65, 0xed, 0x43, 0xf2, 0x48, 0xed, 0x49, 0x6e,0x6b, 0x65, 0xf9, 0x61, 0x6e, 0xe4, 0x6f, 0xf2, 0x63, 0x75, 0xf2, 0x44, 0x69, 0xed, 0x45, 0x6e,
0xe4, 0x46, 0x6f, 0xf2, 0x47, 0x6f, 0x74, 0xef, 0x47, 0x6f, 0x73, 0x75, 0xe2, 0x49, 0xe6, 0x43,0x6f, 0x6e, 0xf4, 0x44, 0x61, 0x74, 0xe1, 0x4c, 0x69, 0x73, 0xf4, 0x52, 0x65, 0x61, 0xe4, 0x4e,
0x65, 0x78, 0xf4, 0x4f, 0xee, 0x50, 0x6f, 0x6b, 0xe5, 0x45, 0x78, 0xf4, 0x52, 0x65, 0x74, 0x75,0x72, 0xee, 0x53, 0x61, 0x76, 0xe5, 0x74, 0x68, 0x65, 0xee, 0x4c, 0x6f, 0x61, 0xe4, 0x52, 0x65,
0x73, 0x74, 0x6f, 0x72, 0xe5, 0x73, 0x74, 0x65, 0xf0, 0x50, 0x6f, 0xf0, 0x4e, 0x65, 0xf7, 0x74,0xef, 0x42, 0x65, 0x65, 0xf0, 0x50, 0x72, 0x69, 0x6e, 0xf4, 0x52, 0x75, 0xee, 0x4d, 0x6f, 0xee,
0x6e, 0x6f, 0xf4, 0x50, 0x6c, 0x6f, 0xf4, 0x43, 0x61, 0x6c, 0xec, 0x49, 0x6e, 0x70, 0x75, 0xf4,0x73, 0x74, 0x72, 0xa4, 0x6c, 0x66, 0x74, 0xa4, 0x72, 0x67, 0x68, 0xa4, 0x63, 0x68, 0x72, 0xa4,
0x6d, 0x69, 0x64, 0xa4, 0x69, 0x6e, 0xf4, 0x61, 0x73, 0xe3, 0x6c, 0x65, 0xee, 0x61, 0x62, 0xf3,0x73, 0x67, 0xee, 0x63, 0x6f, 0xf3, 0x70, 0x65, 0x65, 0xeb, 0x73, 0x71, 0xf2, 0x72, 0x6e, 0xe4,
0x73, 0x69, 0xee, 0x74, 0x61, 0xee, 0x75, 0x73, 0xf2, 0x76, 0x61, 0xec, 0x61, 0x74, 0xee, 0x70,0x6f, 0x69, 0x6e, 0xf4, 0x65, 0x78, 0xf0, 0x6c, 0x6f, 0xe7, 0x8d, 0x8d, 0x8d, 0x66, 0x72, 0xe5,
// 0x44, 0xe4, 0x43, 0xee, 0x50, 0xf0, 0x4f, 0xe4, 0x55, 0xe6, 0x53, 0xee, 0x54, 0xed, 0x55, 0xf3,0x2f, 0xb0, 0x49, 0xf1, 0x4f, 0xed, 0x4f, 0xf6, 0x53, 0xec, 0x42, 0xf3, 0x4f, 0xeb
0x4B, 0x65, 0xF9, 0x4E, 0x65, 0xF7, 0x45, 0x78, 0xF4, 0x45, 0x73, 0x61, 0x76, 0xE5, 0x45, 0x6C, 0x6F, 0x61, 0xE4, 0x4D, 0x65, 0x72, 0x67, 0xE5, 0x56, 0x65, 0x72, 0x69, 0x66, 0xF9, 0x45, 0x64,
0x69, 0xF4, 0x52, 0x65, 0x70, 0x65, 0x61, 0xF4, 0x55, 0x6E, 0x74, 0x69, 0xEC, 0x44, 0x65, 0x6C, 0x65, 0x74, 0xE5, 0x47, 0x6F, 0x73, 0x75, 0x62, 0xA3, 0x47, 0x6F, 0x74, 0x6F, 0xA3, 0x52, 0x65,
0x74, 0x75, 0x72, 0xEE, 0x66, 0x6F, 0x72, 0x6D, 0x24, 0xA8, 0x68, 0x65, 0x78, 0x24, 0xA8, 0x64, 0x65, 0x63, 0xA8, 0x6D, 0x69, 0x6E, 0xA8, 0x6D, 0x61, 0x78, 0xA8, 0x66, 0x73, 0x77, 0xA8, 0x6D,
0x6F, 0x64, 0xA8, 0x50, 0x72, 0xE7, 0x66, 0x72, 0x61, 0xA8, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x24, 0xA8, 0xA5, 0xA4, 0x76, 0x61, 0x72, 0xA8, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0xA8
// ,0x20, 0x65,0x72, 0x72, 0x6f, 0x72, 0x21, 0x8d, 0x0d, 0x42, 0x72, 0x65, 0x61, 0x6b, 0x8d, 0x21, 0xc2, 0x11,0x11, 0x52, 0x40, 0xcd, 0xa3, 0x1f, 0xed, 0xb0, 0x2a, 0x18, 0x40, 0x3e, 0x80, 0xbe, 0x20, 0x0c
 };

void list_tokens() {
    int code=128;
    int i=0;
    while( i<sizeof(tokens) ) {
        printf( "%d.\t%02X %d\t'", i, code, code );
        int i0 = i;
        // show token as characters
        while( ( !(tokens[i] & 128) ) && ( i<sizeof(tokens) ) ) printf( "%c", tokens[i++] & 95 ); // 0b01011111 
        printf( "%c' (%d)\thex: ", tokens[i] & 95, tokens[i] ); // 127
        // show token as hex
        i = i0;
        while( ( !(tokens[i] & 128) ) && ( i<sizeof(tokens) ) ) printf( " %02X", tokens[i++] & 95 );
        printf( " %02X\n", tokens[i] & 95, tokens[i] ); // 127
        i++;
        code++;
    }
}

char charset_conversion_homelab_to_utf( char c ) {
    switch( c ) {
      case 0x04 : return '$'; break;
      case 0x0A : return '*'; break;
      case 0x0B : return '+'; break;
      case 0x0D : return '-'; break;
      case 0x0F : return '/'; break;
      case 0x1E : return '>'; break;
      case 0x1C : return '<'; break;
      case 0x1D : return '='; break;
      default: return c;
    }
}

char charset_conversion_utf_to_homelab( char c ) {
    switch( c ) {
      case '$' : return 0x04; break;
      case '*' : return 0x0A; break;
      case '+' : return 0x0B; break;
      case '-' : return 0x0D; break;
      case '/' : return 0x0F; break;
      case '>' : return 0x1E; break;
      case '<' : return 0x1C; break;
      case '=' : return 0x1D; break;
      default: return toupper( c );
      // default: return c;
    }
}

/**
 * Visszaadja a kódhoz tartozó kulcsszót
 */
#define MAX_TOKEN_LENGTH 20
char token_text[ MAX_TOKEN_LENGTH ]; // Maximális token hossz = 20

char* code_to_h3_token( unsigned char code ) {
    int token_char_index = 0;
    unsigned char current_token_code = 128; // A tokenszavak utolsó karakterének 7. bitje 1. A token azt mondja meg, hogy hányadik(+127) tokenszó a keresett. Az első szó az "^" Ennek kódja 128.
    for( int i=0; i<sizeof( tokens ) && current_token_code <= code; i++ ) {
        if ( code == current_token_code ) token_text[ token_char_index++ ] = charset_conversion_homelab_to_utf( tokens[ i ] & 127 ); // 95 az A8-at elrontja
        if ( tokens[ i ] > 127 ) current_token_code++; // az aktuális token utolsó karaktere
    }
    if ( !token_char_index ) {
        fprintf( stderr, "Token not found for code 0x%02X!\n", code ); exit(8);
    }
    if ( ( code >= 0xAF ) && ( code <= 0xC8 ) ) token_text[ token_char_index++ ] = '(';
    token_text[ token_char_index ] = 0;
    if ( token_char_index > MAX_TOKEN_LENGTH ) {
        fprintf( stderr, "Token too long!\n" ); exit(8);
    }
    return token_text;
}
/*
unsigned char get_token( unsigned char *string, int *string_length ) { // Visszaadja a szóhoz tartozó token kódot, vagy 0 kódot, ha nem tokenizálható.
    int current_token = 127; // A tokenszavak utolsó karakterének 7. bitje 1. A token azt mondja meg, hogy hányadik(+127) tokenszó a keresett. Az első szó az "^" Ennek kódja 128.
    int match_length = 0;
    int skip = 0; // Ha ez 1, akkor nem ellenőrzünk, hanem várjuk, míg vége lesz az aktuális tokennek, amiről tudjuk, hogy rossz
    for( int i=0; i<sizeof( tokens ); i++ ) {
        int last_token_character = tokens[ i ] > 127;
        if ( last_token_character ) current_token++; // Token last char. Increment token counter
        if ( skip ) {
            if ( last_token_character ) skip = 0;
        } else { // Ellenőrzésben vagyunk
            char token_character = tokens[ i ] & 95; // char token_character = last_token_character ? tokens[ i ] & 95 : tokens[ i ];
            if ( token_character == charset_conversion_utf_to_homelab ( string[ match_length ] ) ) { // A keresett karakter jó
                match_length++; // Eggyel több illeszkedik
                if ( last_token_character ) { // Ez volt a token utolsó karaktere, megvagyunk
                    *string_length = match_length; // Az illesztett szó hossza
                    if ( verbose ) {
                        printf( "!!! Found token '" );
                        for( int p=0; p<match_length; p++ ) printf( "%c", string[ p ] );
                        printf( "' code=%02X (%d)\n", current_token, current_token );
                    }
                    return current_token; // Ez a token kódja
                } else if ( match_length >= *string_length ) { // Nincs több illeszthető keresett karakter, ez nem token
                    return 0;
                } // else { // Különben folytatjuk.
            } else { // Nem illeszkedő karakter
                match_length = 0; // Kezdjük előről
                if ( !last_token_character ) skip = 1;
            }
        }
    }
    return 0;
}
*/
